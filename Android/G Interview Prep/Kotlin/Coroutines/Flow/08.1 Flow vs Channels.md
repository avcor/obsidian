## When use [[Flow]] and [[Channels]]
**Flow**
- Primarily used for asynchronous data sequence. 
- Data should be computed [[Flow Operator#Lazily|Lazily]] aka cold. 
- E.g. loading content from db or network request 
- Provides operator like `map`, `filter` 
- Backpressure if consumer is slow, the producer is suspended 
*`SharedFlow` & `StateFlow` act as Hot Streams*

**Channels**
- communication between coroutines
- Always hot and act as queue
- Producer and Consumer pattern 
*Multiple coroutine receiving is supported by `SharedFlow` and use of channels  for this purpose is depreciated* 

## Flow vs Channel

| **Feature**     | **Kotlin Flow**                                              | **Kotlin Channel**                                                           |
| --------------- | ------------------------------------------------------------ | ---------------------------------------------------------------------------- |
| **Nature**      | **Cold** (Passive)                                           | **Hot** (Active)                                                             |
| **Execution**   | **Sequential**                                               | **Concurrent/Producer-Consumer**                                             |
| **Start**       | Starts producing only **when collected** (`collect()`).      | Starts sending/buffering immediately **after creation** (by the producer).   |
| **Delivery**    | **Unicast** (each collector gets the full stream).           | **Unicast** (depending on type, but standard is **Unicast** point-to-point). |
| **Consumption** | Must be consumed via a suspending function like `collect()`. | Must be consumed via a suspending function like `receive()`.                 |

